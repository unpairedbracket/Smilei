
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Parallelization basics &#8212; Smilei v3.4-70-g741f447f documentation</title>
    <link rel="stylesheet" href="_static/smilei_theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/smileiIcon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Binary collisions" href="collisions.html" />
    <link rel="prev" title="PIC algorithms" href="algorithms.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      scale: 95,
      availableFonts: ["TeX"]
    }
  });
  </script>
  
   

  </head><body>

<div id="smallScreenMenu" class="off">

    
    <div class="toctree-smilei">
        <ul>
          <li class="outer">
              <a href="licence.html">Licence</a>
          </li>
          <li class="outer">
              <a href="synopsis.html">Synopsis</a>
          </li>
          <li class="outer">
              <a href="highlights.html">Highlights</a>
          </li>
          <li class="outer">
              <a href="releases.html">Releases</a>
          </li>
        </ul>
        <hr />
        <ul>
          <li class="outer">
              <a href="units.html">Units</a>
          </li>
          <li class="outer">
              <a href="algorithms.html">PIC algorithms</a>
          </li>
        </ul>
            <ul>
<li><a class="reference internal" href="#">Parallelization basics</a><ul>
<li><a class="reference internal" href="#nodes-cores-processes-and-threads">Nodes, cores, processes and threads</a></li>
<li><a class="reference internal" href="#managing-processes-and-threads">Managing processes and threads</a></li>
<li><a class="reference internal" href="#decomposition-of-the-box">Decomposition of the box</a></li>
<li><a class="reference internal" href="#load-balancing-between-mpi-regions">Load balancing between MPI regions</a></li>
<li><a class="reference internal" href="#cartesian-decomposition">Cartesian decomposition</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
</ul>
</li>
</ul>

        <ul>
          <li class="outer">
              <a href="collisions.html">Binary collisions</a>
          </li>
          <li class="outer">
              <a href="field_ionization.html">Field (or user defined) ionization</a>
          </li>
          <li class="outer">
              <a href="radiation_loss.html">Synchrotron-like radiation reaction</a>
          </li>
          <li class="outer">
              <a href="multiphoton_Breit_Wheeler.html">Multiphoton Breit-Wheeler pair creation</a>
          </li>
          <li class="outer">
              <a href="relativistic_fields_initialization.html">Field initialization for relativistic species</a>
          </li>
        </ul>
        <hr />
        <ul>
          <li class="outer">
              <a href="installation.html">Install</a>
          </li>
          <li class="outer">
              <a href="supercomputers.html">Referenced supercomputers</a>
          </li>
          <li class="outer">
              <a href="namelist.html">Write a namelist</a>
          </li>
          <li class="outer">
              <a href="run.html">Run</a>
          </li>
          <li class="outer">
              <a href="post-processing.html">Post-process</a>
          </li>
          <li class="outer">
              <a href="contribute.html">Contribute</a>
          </li>
        </ul>
        <hr />
        <ul>
          <li class="outer">
              <a href="material.html">Publications</a>
          </li>
          <li class="outer">
              <a href="partners.html">Partners</a>
          </li>
          <li class="outer">
              <a href="https://smileipic.github.io/tutorials">Smilei tutorials</a>
          </li>
        </ul>
    </div>

</div>
<div id="hcontainer">
    <div id="nav_positioner">
        <div id="nav">
            <div id="nav_button" onclick="toggleNav()">
                Sections
            </div>
            <div id="nav_list" class="toctree-smilei">
                <div id="nav_title"><a href="#">Parallelization basics</a></div>
                <ul>
<li><a class="reference internal" href="#">Parallelization basics</a><ul>
<li><a class="reference internal" href="#nodes-cores-processes-and-threads">Nodes, cores, processes and threads</a></li>
<li><a class="reference internal" href="#managing-processes-and-threads">Managing processes and threads</a></li>
<li><a class="reference internal" href="#decomposition-of-the-box">Decomposition of the box</a></li>
<li><a class="reference internal" href="#load-balancing-between-mpi-regions">Load balancing between MPI regions</a></li>
<li><a class="reference internal" href="#cartesian-decomposition">Cartesian decomposition</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
</ul>
</li>
</ul>

            </div>
        </div>
    </div>
    
    <div class="headercolor">
    </div>
    <div class="hpositioner">
        <div class="header">
        <div class="logo">
            <a href="index.html">
                <img class="logo" src="_static/smileiLogo.svg" alt="Logo" />
            </a>
        </div>
        
    
            
        
        <div class="menu" id="menu_Licence">
            <div id="menuButton_Licence" class="menuButton"
                 onmouseenter="prepareMenu('menu_Licence')"
                 onmousedown="event.preventDefault()"
            >
                <span>Overview</span>
            </div>
            <div class="off" onmouseleave="leaveMenu('menu_Licence',this)">
                <div class="toctree-smilei">
                    <ul>
                        <li class="outer">
                            <a href="licence.html">Licence</a>
                        </li>
                        <li class="outer">
                            <a href="synopsis.html">Synopsis</a>
                        </li>
                        <li class="outer">
                            <a href="highlights.html">Highlights</a>
                        </li>
                        <li class="outer">
                            <a href="releases.html">Releases</a>
                        </li>
            
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="menu" id="menu_Units" style="font-weight:bold">
            <div id="menuButton_Units" class="menuButton"
                 onmouseenter="prepareMenu('menu_Units')"
                 onmousedown="event.preventDefault()"
            >
                <span>Understand</span>
            </div>
            <div class="off" onmouseleave="leaveMenu('menu_Units',this)">
                <div class="toctree-smilei">
                    <ul>
                        <li class="outer">
                            <a href="units.html">Units</a>
                        </li>
                        <li class="outer">
                            <a href="algorithms.html">PIC algorithms</a>
                        </li>
                        <li >
                            <a href="#">Parallelization basics</a>
                        </li>
                        <li class="outer">
                            <a href="collisions.html">Binary collisions</a>
                        </li>
                        <li class="outer">
                            <a href="field_ionization.html">Field (or user defined) ionization</a>
                        </li>
                        <li class="outer">
                            <a href="radiation_loss.html">Synchrotron-like radiation reaction</a>
                        </li>
                        <li class="outer">
                            <a href="multiphoton_Breit_Wheeler.html">Multiphoton Breit-Wheeler pair creation</a>
                        </li>
                        <li class="outer">
                            <a href="relativistic_fields_initialization.html">Field initialization for relativistic species</a>
                        </li>
            
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="menu" id="menu_Install">
            <div id="menuButton_Install" class="menuButton"
                 onmouseenter="prepareMenu('menu_Install')"
                 onmousedown="event.preventDefault()"
            >
                <span>Use</span>
            </div>
            <div class="off" onmouseleave="leaveMenu('menu_Install',this)">
                <div class="toctree-smilei">
                    <ul>
                        <li class="outer">
                            <a href="installation.html">Install</a>
                        </li>
                        <li class="outer">
                            <a href="supercomputers.html">Referenced supercomputers</a>
                        </li>
                        <li class="outer">
                            <a href="namelist.html">Write a namelist</a>
                        </li>
                        <li class="outer">
                            <a href="run.html">Run</a>
                        </li>
                        <li class="outer">
                            <a href="post-processing.html">Post-process</a>
                        </li>
                        <li class="outer">
                            <a href="contribute.html">Contribute</a>
                        </li>
            
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="menu" id="menu_Publications">
            <div id="menuButton_Publications" class="menuButton"
                 onmouseenter="prepareMenu('menu_Publications')"
                 onmousedown="event.preventDefault()"
            >
                <span>More</span>
            </div>
            <div class="off" onmouseleave="leaveMenu('menu_Publications',this)">
                <div class="toctree-smilei">
                    <ul>
                        <li class="outer">
                            <a href="material.html">Publications</a>
                        </li>
                        <li class="outer">
                            <a href="partners.html">Partners</a>
                        </li>
                        <li class="outer">
                            <a href="https://smileipic.github.io/tutorials">Smilei tutorials</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            var es=document.getElementsByClassName("menuButton"), i=0;
            var evt = "ontouchend" in document ? "touchend" : "click";
            for( var i=0; i<es.length; i+=1 ) {
                es[i].addEventListener(evt, function(a){ return function(){toggleMenu(a)};}(es[i].parentNode.id));
            }
        </script>
        
        <div id="searchbox" role="search" style="display:none">
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" placeholder="Search" id="searchinput" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
        
        <div id="searchicon" onclick="openSearch()" style="display:block">
            <svg
               xmlns="http://www.w3.org/2000/svg"
               viewBox="0 0 80 120">
              <g transform="translate(0,-932.36216)" >
                <circle
                   r="25" cy="977.51044" cx="38.078663"
                   style="opacity:1;fill:none;stroke:#ffffff;stroke-width:10;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
                <rect
                   transform="matrix(0.36717877,0.93015039,-0.93427297,0.35655858,0,0)"
                   rx="4.9996676" ry="7.4995141"
                   y="316.16959" x="947.6142"
                   height="14.117695" width="46.476151"
                   style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;" />
                <path
                   d="m 41.383282,962.25996 a 15,15 0 0 1 11.660107,11.6355"
                   style="opacity:1;fill:none;stroke:#ffffff;stroke-width:3;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
              </g>
            </svg>
        </div>
        <div id="closesearchicon" onclick="closeSearch()" style="display:none">
            <svg
               xmlns="http://www.w3.org/2000/svg"
               viewBox="0 0 80 120">
              <g
                 transform="translate(0,-932.36216)">
                <path
                   d="m 10,962.36216 60,60.00004"
                   style="fill:none;stroke:#ffffff;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none" />
                <path
                   d="M 70,962.36216 10,1022.3622"
                   style="fill:none;stroke:#ffffff;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none" />
              </g>
            </svg>
        </div>
        
        <div id="smallScreenMenuButton" onclick="toggleSmallScreenMenu(event)">
            <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg"
               viewBox="-20 -20 140 140">
              <g  style="fill:#ffffff;stroke:none;">
                <circle cx="15" cy="20" r="5" />
                <circle cx="35" cy="20" r="5" />
                <circle cx="85" cy="20" r="5" />
                <rect width="50" height="10" x="35" y="15" rx="0" ry="0" />
                <circle cx="15" cy="40" r="5" />
                <circle cx="35" cy="40" r="5" />
                <circle cx="85" cy="40" r="5" />
                <rect width="50" height="10" x="35" y="35" rx="0" ry="0" />
                <circle cx="15" cy="60" r="5" />
                <circle cx="35" cy="60" r="5" />
                <circle cx="85" cy="60" r="5" />
                <rect width="50" height="10" x="35" y="55" rx="0" ry="0" />
                <circle cx="15" cy="80" r="5" />
                <circle cx="35" cy="80" r="5" />
                <circle cx="85" cy="80" r="5" />
                <rect width="50" height="10" x="35" y="75" rx="0" ry="0" />
              </g>
            </svg>
        </div>
        
    </div>
    
</div>
</div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="collisions.html" title="Binary collisions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="PIC algorithms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Smilei v3.4-70-g741f447f documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
  <div class="section" id="parallelization-basics">
<h1>Parallelization basics<a class="headerlink" href="#parallelization-basics" title="Permalink to this headline">¶</a></h1>
<p>For high performance, <strong class="program">Smilei</strong> makes complex use of parallel computing,
and it is important to understand the basics of this technology. Parallel simply
means that many processors can run the simulation at the same time, but there is
much more than that.</p>
<hr class="docutils" />
<div class="section" id="nodes-cores-processes-and-threads">
<h2>Nodes, cores, processes and threads<a class="headerlink" href="#nodes-cores-processes-and-threads" title="Permalink to this headline">¶</a></h2>
<p>Supercomputers have complex architectures, mainly due to their processors
capability to <strong>work together on the same memory space</strong>. More precisely, <em>cores</em>
are grouped in <em>nodes</em> (1). All the cores in one node share the same memory space.
This hardware architecture is summarized in <a class="reference internal" href="#nodescoresthreads"><span class="std std-numref">Fig. 1</span></a>.</p>
<div class="figure" id="id1">
<span id="nodescoresthreads"></span><a class="reference internal image-reference" href="_images/NodesCoresThreads.png"><img alt="_images/NodesCoresThreads.png" src="_images/NodesCoresThreads.png" style="width: 11cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Simplified super-computer architecture.</span></p>
</div>
<p>This same figure shows how the software is structured. <em>Processes</em> are the macroscopic
units which are designed to compute over a reserved space in memory (one process
will not handle the memory of another process), and manage several cores.
To treat these cores, a process must provide several <em>threads</em>. A thread is basically the
sequence of instructions from the program, which must be executed by one core.
However, a thread is not uniquely associated to one core: a core can in general run multiple threads alternatively.
The number of threads a core can handle depends on the architecture.</p>
<p>The association between the software <em>threads</em> and the hardware <em>cores</em> can be more
complicated. <a class="reference internal" href="#nodewith2processes"><span class="std std-numref">Fig. 2</span></a> shows an example where two processes share the
same node. In this case, we illustrate the memory of this node as split in two parts because
the two processes cannot access to the same memory.</p>
<div class="figure" id="id2">
<span id="nodewith2processes"></span><a class="reference internal image-reference" href="_images/NodeWith2Processes.png"><img alt="_images/NodeWith2Processes.png" src="_images/NodeWith2Processes.png" style="width: 6cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">An example where two processes share the same node.</span></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">(1) The terminology of <em>nodes, cores, processes and threads</em> is not universal. Depending
on the computer, software (etc.), they can have various meanings.</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="managing-processes-and-threads">
<h2>Managing processes and threads<a class="headerlink" href="#managing-processes-and-threads" title="Permalink to this headline">¶</a></h2>
<p>Although processes do not share their memory, they must sometimes synchronize their
advance in the execution of the program, or communicate data between each other.
For instance, to calculate the total energy in the simulation, they must communicate
their contribution to the others and compute the sum.
In <strong class="program">Smilei</strong>, these tasks are accomplished by the Message Passing Interface (MPI) protocol.</p>
<p>At the thread level, the communications do not work in the same manner because threads
already share their data. However, they need synchronization and management to decide
which core handles which thread. In <strong class="program">Smilei</strong>, this is accomplished by the <em>OpenMP</em> protocol.</p>
<p>An illustration of the roles of MPI and OpenMP is provided in <a class="reference internal" href="#mpiandopenmp"><span class="std std-numref">Fig. 3</span></a></p>
<div class="figure" id="id3">
<span id="mpiandopenmp"></span><a class="reference internal image-reference" href="_images/MPIandOpenMP.png"><img alt="_images/MPIandOpenMP.png" src="_images/MPIandOpenMP.png" style="width: 9cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">MPI handles process-to-process communications, while OpenMP manages threads in a given process.</span></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="decomposition-of-the-box">
<h2>Decomposition of the box<a class="headerlink" href="#decomposition-of-the-box" title="Permalink to this headline">¶</a></h2>
<p>Traditionally, PIC codes would
split the spatial grid into <span class="math notranslate nohighlight">\(N\)</span> domains, where <span class="math notranslate nohighlight">\(N\)</span> is the number
of cores. Each core would manage its own domain on a separate memory space,
and information is communicated between cores using the MPI protocol.
<strong class="program">Smilei</strong> proposes an more efficient approach:
it also decomposes the spatial grid in several domains,
but one core is not directly associated to one domain.</p>
<p>Let us explain this difference in details.
<a class="reference internal" href="#patchdecomposition"><span class="std std-numref">Fig. 4</span></a> gives an example of a grid containing 960 cells.
It is decomposed in <span class="math notranslate nohighlight">\(4\times8 = 32\)</span> domains, called <strong>patches</strong>.
Each patch has <span class="math notranslate nohighlight">\(5\times6\)</span> cells.
These patch size is actually reasonable for <strong class="program">Smilei</strong>, whereas
traditional PIC codes would have much larger domains.</p>
<p>The issue is now to decide where these patches will be stored in the memory,
and to choose which cores should handle which patches.
Recall that all the cores handled by one process share the same memory:
we will refer to this memory as an <em>MPI region</em>.
This means that one process manages one exclusive MPI region.
<a class="reference internal" href="#patchdecomposition"><span class="std std-numref">Fig. 4</span></a> shows an example with the 32 patches split in 5 regions
recognized by their different colors.
Note that these regions are formed by contiguous patches (the regions are connex), but not necessarily rectangular.</p>
<div class="figure" id="id4">
<span id="patchdecomposition"></span><a class="reference internal image-reference" href="_images/PatchDecomposition.png"><img alt="_images/PatchDecomposition.png" src="_images/PatchDecomposition.png" style="width: 10cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Decomposition of a grid in <em>patches</em> and <em>MPI regions</em>.</span></p>
</div>
<p>Each MPI region is handled by all the threads of the process. For example, if there are
4 threads in the process that handles the region colored in green, this means the
4 threads will handle 10 patches. The 4 threads will work in parallel, patch by patch,
until all patches are done.</p>
<p>The great advantage of this scheme is that, inside one MPI region, the threads do not
need to wait for their friends to go to the next patch; they can continue working on
the available patches, thus avoiding long waiting times.
This is a form of <strong>local load balancing</strong>.</p>
<p class="rubric">Rules</p>
<ul class="simple">
<li>In each direction <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>, the number of patches must be
a power of 2.</li>
<li>For efficiency reasons, each MPI process should own more patches than threads. And even many more if possible.</li>
</ul>
<hr class="docutils" />
</div>
<div class="section" id="load-balancing-between-mpi-regions">
<span id="loadbalancingexplanation"></span><h2>Load balancing between MPI regions<a class="headerlink" href="#load-balancing-between-mpi-regions" title="Permalink to this headline">¶</a></h2>
<p>As we just explained, threads treat the patches in one MPI region asynchronously to
balance their computational loads.
Indeed, some patches may have more particles than others and therefore represent a heavier load for the thread
which has to deal with it. In the meantime, other threads can take care of several lighter patches.
Unfortunately, it may not be sufficient.
When one MPI region holds more total load than the others, it will take a long
time to compute, while the other processes have already finished and wait for this one.
This can cause large delays.</p>
<p><strong class="program">Smilei</strong> has an algorithm able to reduce this imbalance by exchanging patches
from one MPI region to another. A process that has too much load will give patches to
other processes in order to reduce the size of its MPI region. This algorithm is based
on an ordering of the patches by a <em>Hilbert curve</em>, as drawn in
<a class="reference internal" href="#patchdecompositionhilbert"><span class="std std-numref">Fig. 5</span></a>. One MPI region contains only patches that contiguously
follow this curve. If this “portion” of the curve has too much load, it will send
some patches to the portions ahead or after, along the same curve. By repeating this
operation every now and then, we ensure that all regions manage an equitable computational load.</p>
<div class="figure" id="id5">
<span id="patchdecompositionhilbert"></span><a class="reference internal image-reference" href="_images/PatchDecompositionHilbert.png"><img alt="_images/PatchDecompositionHilbert.png" src="_images/PatchDecompositionHilbert.png" style="width: 8cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">The shape of the Hilbert curve which determines the patch order.</span></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="cartesian-decomposition">
<h2>Cartesian decomposition<a class="headerlink" href="#cartesian-decomposition" title="Permalink to this headline">¶</a></h2>
<p>To be efficient, the dynamic load balancing process requires particles.
For simulations with very local plasma it worths to manage handly the domain decomposition.
Given that the distriubtion of patches along the space filling curve is not intuitive, it is possible to use a classical cartesian distribution.</p>
<p>In the namelist :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Main</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">patch_decomposition</span> <span class="o">=</span> <span class="s2">&quot;cartesian&quot;</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Rules</p>
<ul class="simple">
<li>No more limits on the number of patches per direction.</li>
<li>This option disables the load balancing.</li>
<li><dl class="first docutils">
<dt>To use fields diagnostics, the number of patches per process must allow to build regular pavement of the simulation box. For instance :</dt>
<dd><ul class="first last">
<li>8 x 8 patches on 4 MPI process : <strong>ok</strong>, each process own 2 x 8 patches slice.</li>
<li>6 x 8 patches on 4 MPI process : <strong>not ok</strong>, each process own 12 patches which overlap 2 pavements.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>By default, the cartesian decomposition is oriented to store contiguously patches along the most internal direction (<strong>Z</strong>, then <strong>Y</strong>, then <strong>X</strong>).
The orientation can be modified throught the following option :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Main</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">patch_orientation</span> <span class="o">=</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span>  <span class="c1"># 2D</span>
    <span class="n">patch_orientation</span> <span class="o">=</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">,</span> <span class="c1"># 3D</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Reminder</p>
<ul class="simple">
<li>This option is not compatible with the usage of fields diagnostics.</li>
<li>These parameters are optional, without specfication of the patches distribution the Hilbert curve is used.</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="recommendations">
<h2>Recommendations<a class="headerlink" href="#recommendations" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><strong>Have as many MPI processes as sockets</strong> in order to optimize the memory distribution.</p>
</li>
<li><p class="first"><strong>have as many threads as cores per MPI process</strong>.
If you have less threads than cores, you will not be using all your cores.
Use more threads than cores only if your architecture supports it well.</p>
</li>
<li><p class="first">Use dynamic scheduling for the OpenMP parallelism, by setting the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_SCHEDULE</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">OMP_SCHEDULE</span><span class="o">=</span><span class="n">dynamic</span>
</pre></div>
</div>
<p>This affects only the particles treatment, which will dynamically assign threads.
Note that fields are always statically assigned to threads.</p>
</li>
<li><p class="first"><strong>Have small patches</strong>. Be aware that the minimum size of patch depends on the order of the numerical methods you use.
For typical order 2, the minimum size is 5 cells per dimension.
This allows good cache use, and good load distribution between threads.
Warning: it is commonly advised to use larger patches if more than half of your simulation domain is empty of particles.</p>
</li>
<li><p class="first"><strong>Take these recommendations with a pinch of salt</strong>. Do your own tests and send us feedback !</p>
</li>
</ul>
</div>
</div>


        </div></div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="collisions.html" title="Binary collisions"
             >next</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="PIC algorithms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Smilei v3.4-70-g741f447f documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer">
      <div>
      <a href="site.html">Site index</a>
      </div>
      <div>
        Last updated on Jul 11, 2018
      </div>
      
      <div>
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      </div>
      
    </div>
    
    <script type="text/javascript">
        
        var nav = document.getElementById("nav");
        var nav_list = document.getElementById("nav_list");
        var nav_button = document.getElementById("nav_button");
        var smallScreenMenu = document.getElementById("smallScreenMenu");
        var smallScreenMenuButton = document.getElementById("smallScreenMenuButton");
        var searchicon = document.getElementById("searchicon");
        var searchbox  = document.getElementById("searchbox");
        var searchinput= document.getElementById("searchinput");
        var menus = document.getElementsByClassName("menu");
        for( var i=0; i<menus.length; i++ )
            menus[i].active = false;
        
        
        var ul = nav_list.getElementsByTagName("ul")[0], li;
        var keep_nav = false;
        if( ul ) {
            li = ul.firstElementChild;
            if( li ) {
                if( li.getElementsByTagName("ul").length > 0 ) keep_nav = true;
            }
        }
        if( keep_nav ) {
            li.removeChild( li.firstElementChild );
        } else {
            document.getElementById("nav_positioner").removeChild( document.getElementById("nav") );
        }
        
        function navOff() {
            nav_list.style.display = "none";
            nav_button.className = "";
            nav.style.overflowY = "visible";
        }
        
        function toggleNav() {
            for( var i=0; i<menus.length; i++ )
                menuOff( menus[i] );
            if( nav_list.style.display != "inline-block" ) {
                nav_list.style.display = "inline-block";
                nav_button.className = "pushed";
                nav.style.overflowY = "auto";
            } else {
                navOff();
            }
        }
        
        function toggleSmallScreenMenu(e) {
            e.preventDefault();
            if( smallScreenMenu.className != "on" ) {
                smallScreenMenu.className = "on";
                smallScreenMenuButton.className = "pushed";
            } else {
                smallScreenMenu.className = "off";
                smallScreenMenuButton.className = "";
            }
        }
        
        function prepareMenu(menu_id) {
            var menu = document.getElementById(menu_id);
            menu.timer1 = setTimeout(function(a){ return function(){thisMenuOnly(a)};}(menu_id), 100);
            menu.addEventListener("mouseleave", function(a){ return function(){clearTimeout(a.timer1)};}(menu) );
        }
        
        function leaveMenu(menu_id, source) {
            var menu = document.getElementById(menu_id);
            menu.timer2 = setTimeout(function(a){ return function(){menuOff(a)};}(menu), 1000);
            source.addEventListener("mouseenter", function(a){ return function(){clearTimeout(a.timer2)};}(menu) );
        }
        
        function menuOn( menu ) {
            var divs = menu.getElementsByTagName("div");
            if(nav_list) navOff();
            divs[1].className = "on";
            divs[0].className = "menuButton pushed";
            menu.active = true;
        }
        function menuOff( menu ) {
            var divs = menu.getElementsByTagName("div");
            divs[1].className = "off";
            divs[0].className = "menuButton";
            menu.active = false;
        }
        
        function thisMenuOnly(menu_id) {
            var menu = document.getElementById(menu_id);
            for( var i=0; i<menus.length; i++ )
                if( i!=menu_id )
                    menuOff( menus[i] );
            menuOn( menu );
        }
        
        function toggleMenu(menu_id) {
            var menu = document.getElementById(menu_id);
            if( menu.active ) {
                menuOff( menu );
            } else {
                for( var i=0; i<menus.length; i++ )
                    if( i!=menu_id )
                        menuOff( menus[i] );
                menuOn( menu );
            }
        }
        
        function openSearch() {
            for( var i=0; i<menus.length; i++ ) {
                menuOff( menus[i] );
                menus[i].style.zIndex = "-1";
            }
            searchicon.style.display = "none";
            closesearchicon.style.display = "block";
            searchbox.style.display = "block";
            searchinput.focus();
        }
        
        function closeSearch() {
            searchicon.style.display = "block";
            closesearchicon.style.display = "none";
            searchbox .style.display = "none";
            for( var i=0; i<menus.length; i++ )
                menus[i].style.zIndex = "0";
        }
        
        
        var documentDiv = document.getElementsByClassName("document")[0];
        documentDiv.addEventListener('click', function (event) {
            if(nav_list) navOff();
            for( var i=0; i<menus.length; i++ )
                menuOff( menus[i] );
        });
    </script>
  </body>
</html>